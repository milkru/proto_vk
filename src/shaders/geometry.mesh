#version 460

#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_mesh_shader: require

#include "common.h"

layout(local_size_x = kShaderGroupSize) in;
layout(triangles, max_vertices = kMaxVerticesPerMeshlet, max_primitives = kMaxTrianglesPerMeshlet) out;

layout(binding = 0) uniform UniformBufferObject { PerFrameData perFrameData; };
layout(binding = 1) readonly buffer PerDrawDataVector { PerDrawData perDrawDataVector[]; };
layout(binding = 2) readonly buffer DrawCommands { DrawCommand drawCommands[]; };
layout(binding = 3) readonly buffer Meshlets { Meshlet meshlets[]; };
layout(binding = 4) readonly buffer Meshes { Mesh meshes[]; };
layout(binding = 5) readonly buffer MeshletVertices { u32 meshletVertices[]; };
layout(binding = 6) readonly buffer MeshletTriangles { uint8_t meshletTriangles[]; };
layout(binding = 7) readonly buffer Vertices { Vertex vertices[]; };

layout(location = 0) out v3 outColor[];

taskPayloadSharedEXT u32 meshletIndices[kShaderGroupSize];
shared v3 clipPositions[kMaxVerticesPerMeshlet];

void main()
{
	u32 groupIndex = gl_WorkGroupID.x;
	u32 groupThreadIndex = gl_LocalInvocationID.x;
	u32 meshletIndex = meshletIndices[groupIndex]; 
	
	u32 drawIndex = drawCommands[gl_DrawID].drawIndex;
	PerDrawData perDrawData = perDrawDataVector[drawIndex];

	v3 meshletColor = getRandomColor(meshletIndex);
	u32 globalVertexOffset = meshes[perDrawData.meshIndex].vertexOffset;

	for (u32 localVertexIndex = groupThreadIndex;
		localVertexIndex < meshlets[meshletIndex].vertexCount;
		localVertexIndex += kShaderGroupSize)
	{
		u32 vertexIndex = globalVertexOffset + meshletVertices[meshlets[meshletIndex].vertexOffset + localVertexIndex];
		
		v3 position = v3(
			vertices[vertexIndex].position[0],
			vertices[vertexIndex].position[1],
			vertices[vertexIndex].position[2]);

		v4 worldPosition = perDrawData.model * v4(position, 1.0);

		v3 normal = v3(
			i32(vertices[vertexIndex].normal[0]),
			i32(vertices[vertexIndex].normal[1]),
			i32(vertices[vertexIndex].normal[2])) / 127.0 - 1.0;
			
		normal = m3(perDrawData.model) * normalize(normal);

		v2 texCoord = v2(
			vertices[vertexIndex].texCoord[0],
			vertices[vertexIndex].texCoord[1]);

		gl_MeshVerticesEXT[localVertexIndex].gl_Position = perFrameData.projection * perFrameData.view * worldPosition;
		
		v4 freezeClipPosition = perFrameData.projection * perFrameData.freezeView * worldPosition;
		clipPositions[localVertexIndex] = freezeClipPosition.xyz / freezeClipPosition.w;
		
		f32 shade = dot(normal, normalize(perFrameData.cameraPosition.xyz - worldPosition.xyz));
		outColor[localVertexIndex] = shade * (0.5 * (meshletColor + 0.5 * normal + 0.5));
	}
	
	v2 screenSize = v2(perFrameData.screenWidth, perFrameData.screenHeight);
	
	bool bSmallTriangleCullingEnabled = perFrameData.bSmallTriangleCullingEnabled == 1;
	bool bBackfaceCullingEnabled = perFrameData.bTriangleBackfaceCullingEnabled == 1;

	for (u32 localTriangleIndex = groupThreadIndex;
		localTriangleIndex < meshlets[meshletIndex].triangleCount;
		localTriangleIndex += kShaderGroupSize)
	{
		// Triangle culling:
		// https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2016/Presentations/Wihlidal_Graham_OptimizingTheGraphics.pdf

		bool bVisible = true;

		u32 triangleIndex0 = u32(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 0]);
		u32 triangleIndex1 = u32(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 1]);
		u32 triangleIndex2 = u32(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 2]);

		v2 screenPosition0 = (0.5 + 0.5 * clipPositions[triangleIndex0]).xy * screenSize;
		v2 screenPosition1 = (0.5 + 0.5 * clipPositions[triangleIndex1]).xy * screenSize;
		v2 screenPosition2 = (0.5 + 0.5 * clipPositions[triangleIndex2]).xy * screenSize;
		
		if (bVisible && bSmallTriangleCullingEnabled)
		{
			f32 minX = min(min(screenPosition0.x, screenPosition1.x), screenPosition2.x);
			f32 minY = min(min(screenPosition0.y, screenPosition1.y), screenPosition2.y);
			f32 maxX = max(max(screenPosition0.x, screenPosition1.x), screenPosition2.x);
			f32 maxY = max(max(screenPosition0.y, screenPosition1.y), screenPosition2.y);

			bool bSmallTriangleCulled =
				u32(round(minX)) == u32(round(maxX)) ||
				u32(round(minY)) == u32(round(maxY));

			bVisible = bVisible && !bSmallTriangleCulled;
		}

		if (bVisible && bBackfaceCullingEnabled)
		{
			v3 edgeVector0 = v3(screenPosition1 - screenPosition0, 0);
			v3 edgeVector1 = v3(screenPosition2 - screenPosition1, 0);
			v3 triangleOrientation = cross(edgeVector0, edgeVector1);

			bool bBackfaceCulled = triangleOrientation.z >= 0;
			bVisible = bVisible && !bBackfaceCulled;
		}
		
		gl_MeshPrimitivesEXT[localTriangleIndex].gl_CullPrimitiveEXT = !bVisible;
		gl_PrimitiveTriangleIndicesEXT[localTriangleIndex] = uv3(triangleIndex0, triangleIndex1, triangleIndex2);
	}

	SetMeshOutputsEXT(meshlets[meshletIndex].vertexCount, meshlets[meshletIndex].triangleCount);
}
