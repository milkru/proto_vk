#version 460

#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_mesh_shader: require

#include "shader_common.h"

layout(local_size_x = kShaderGroupSize) in;
layout(triangles, max_vertices = kMaxVerticesPerMeshlet, max_primitives = kMaxTrianglesPerMeshlet) out;

layout(binding = 0) uniform UniformBufferObject { PerFrameData perFrameData; };
layout(binding = 1) readonly buffer PerDrawDataVector { PerDrawData perDrawDataVector[]; };
layout(binding = 2) readonly buffer DrawCommands { DrawCommand drawCommands[]; };
layout(binding = 3) readonly buffer Meshlets { Meshlet meshlets[]; };
layout(binding = 4) readonly buffer Meshes { Mesh meshes[]; };
layout(binding = 5) readonly buffer MeshletVertices { uint meshletVertices[]; };
layout(binding = 6) readonly buffer MeshletTriangles { uint8_t meshletTriangles[]; };
layout(binding = 7) readonly buffer Vertices { Vertex vertices[]; };

taskPayloadSharedEXT uint meshletIndices[kShaderGroupSize];

layout(location = 0) out vec3 outColor[];

void main()
{
	// TODO-MILKRU: Implement backface and small triangle culling

	uint groupIndex = gl_WorkGroupID.x;
	uint groupThreadIndex = gl_LocalInvocationID.x;
	uint meshletIndex = meshletIndices[groupIndex]; 
	
	uint drawIndex = drawCommands[gl_DrawID].drawIndex;
	PerDrawData perDrawData = perDrawDataVector[drawIndex];

	vec3 meshletColor = getRandomColor(meshletIndex);
	uint globalVertexOffset = meshes[perDrawData.meshIndex].vertexOffset;

	for (uint localVertexIndex = groupThreadIndex;
		localVertexIndex < meshlets[meshletIndex].vertexCount;
		localVertexIndex += kShaderGroupSize)
	{
		uint vertexIndex = globalVertexOffset + meshletVertices[meshlets[meshletIndex].vertexOffset + localVertexIndex];
		
		vec3 position = vec3(
			vertices[vertexIndex].position[0],
			vertices[vertexIndex].position[1],
			vertices[vertexIndex].position[2]);

		vec4 worldPosition = perDrawData.model * vec4(position, 1.0);

		vec3 normal = vec3(
			int(vertices[vertexIndex].normal[0]),
			int(vertices[vertexIndex].normal[1]),
			int(vertices[vertexIndex].normal[2])) / 127.0 - 1.0;
			
		normal = mat3(perDrawData.model) * normalize(normal);

		vec2 texCoord = vec2(
			vertices[vertexIndex].texCoord[0],
			vertices[vertexIndex].texCoord[1]);

		gl_MeshVerticesEXT[localVertexIndex].gl_Position = perFrameData.projection * perFrameData.view * worldPosition;
		
		float shade = dot(normal, normalize(perFrameData.cameraPosition.xyz - worldPosition.xyz));
		outColor[localVertexIndex] = shade * (0.5 * (meshletColor + 0.5 * normal + 0.5));
	}

	for (uint localTriangleIndex = groupThreadIndex;
		localTriangleIndex < meshlets[meshletIndex].triangleCount;
		localTriangleIndex += kShaderGroupSize)
	{
		gl_PrimitiveTriangleIndicesEXT[localTriangleIndex] = uvec3(
			uint(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 0]),
			uint(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 1]),
			uint(meshletTriangles[meshlets[meshletIndex].triangleOffset + 3 * localTriangleIndex + 2]));
	}

	SetMeshOutputsEXT(meshlets[meshletIndex].vertexCount, meshlets[meshletIndex].triangleCount);
}
