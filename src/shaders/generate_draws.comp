#version 460

#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_KHR_shader_subgroup_ballot: require

#include "common.h"

layout(local_size_x = kShaderGroupSize) in;
layout(local_size_y = 1) in;
layout(local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject { PerFrameData perFrameData; };
layout(binding = 1) readonly buffer Meshes { Mesh meshes[]; };
layout(binding = 2) readonly buffer PerDrawDataVector { PerDrawData perDrawDataVector[]; };
layout(binding = 3) writeonly buffer DrawCommands { DrawCommand drawCommands[]; };
layout(binding = 4) buffer DrawCount { u32 drawCount; };
layout(binding = 5) buffer MeshVisibility { u32 meshVisibility[]; };
layout(binding = 6) uniform sampler2D hzb;

layout (push_constant) uniform block
{
    PerPassData perPassData;
};

void main()
{
	u32 groupThreadIndex = gl_LocalInvocationID.x;
	u32 drawIndex = gl_GlobalInvocationID.x;

	if (drawIndex >= perFrameData.maxDrawCount)
	{
		return;
	}
	
	bool bPrepass = perPassData.bPrepass == 1;

	PerDrawData perDrawData = perDrawDataVector[drawIndex];
	Mesh mesh = meshes[perDrawData.meshIndex];
	
	v3 center = (perDrawData.model * v4(
		mesh.center[0],
		mesh.center[1],
		mesh.center[2], 1.0)).xyz;
	
	// TODO-MILKRU: Multiply mesh bounding spheres by scale

	bool bVisible = bPrepass ? meshVisibility[drawIndex] == 1 : true;

	bool bFrustumCullingEnabled = perFrameData.bMeshFrustumCullingEnabled == 1;
	if (bVisible && bFrustumCullingEnabled)
	{
		bool bFrustumCulled = false;
		
		[[unroll]]
		for (i32 i = 0; i < kFrustumPlaneCount; ++i)
		{
			bFrustumCulled = bFrustumCulled ||
				dot(v4(center, 1.0), perFrameData.freezeFrustumPlanes[i]) + mesh.radius < 0.0;
		}
		
		bVisible = !bFrustumCulled;
	}
	
	bool bOcclusionCullingEnabled = perFrameData.bMeshOcclusionCullingEnabled == 1;
	if (!bPrepass)
	{
		if (bVisible && bOcclusionCullingEnabled)
		{
			v3 centerViewSpace = (perFrameData.freezeView * v4(center, 1.0)).xyz;
			f32 P00 = perFrameData.projection[0][0];
			f32 P11 = perFrameData.projection[1][1];
			f32 zNear = perFrameData.projection[3][2];
			v4 AABB;

			if (tryCalculateSphereBounds(centerViewSpace, mesh.radius, zNear, P00, P11, AABB))
			{
				f32 boundsWidth = (AABB.z - AABB.x) * f32(perFrameData.hzbSize);
				f32 boundsHeight = (AABB.w - AABB.y) * f32(perFrameData.hzbSize);
				f32 mipIndex = floor(log2(max(boundsWidth, boundsHeight)));

				f32 occluderDepth = textureLod(hzb, 0.5 * (AABB.xy + AABB.zw), mipIndex).x;
				f32 nearestBoundsDepth = zNear / (-centerViewSpace.z - mesh.radius);

				bool bOcclusionCulled = occluderDepth >= nearestBoundsDepth;
				bVisible = !bOcclusionCulled;
			}
		}
	}
	
	bool bMeshletOcclusionCullingEnabled = perFrameData.bMeshletOcclusionCullingEnabled == 1;
	bool bDrawMesh = bPrepass || bMeshletOcclusionCullingEnabled ? bVisible : bVisible && meshVisibility[drawIndex] == 0;
	uv4 drawMeshBallot = subgroupBallot(bDrawMesh);

	u32 drawOffset;
	if (subgroupElect())
	{
		u32 drawMeshCount = subgroupBallotBitCount(drawMeshBallot);
		drawOffset = atomicAdd(drawCount, drawMeshCount);
	}
	drawOffset = subgroupBroadcastFirst(drawOffset);

	f32 meshToCameraDistance = distance(center, perFrameData.freezeCameraPosition.xyz);
	u32 lodIndex = u32(max(1.0 +
		log(meshToCameraDistance / perFrameData.lodTransitionBase) /
		log(perFrameData.lodTransitionStep), 0.0));

	lodIndex = perFrameData.forcedLod < 0 ?
		min(lodIndex, mesh.lodCount - 1) :
		min(perFrameData.forcedLod, mesh.lodCount - 1);

	MeshLod meshLod = mesh.lods[lodIndex];
	
	if (bDrawMesh)
	{
		DrawCommand drawCommand;
		drawCommand.taskX = (meshLod.meshletCount + kShaderGroupSize - 1) / kShaderGroupSize;
		drawCommand.taskY = 1;
		drawCommand.taskZ = 1;

		drawCommand.drawIndex = drawIndex;
		drawCommand.lodIndex = lodIndex;
		drawCommand.meshVisibility = meshVisibility[drawIndex];
		
		u32 drawMeshIndex = subgroupBallotExclusiveBitCount(drawMeshBallot);

		u32 drawCommandIndex = drawOffset + drawMeshIndex;
		drawCommands[drawCommandIndex] = drawCommand;
	}
	
	if (!bPrepass)
	{
		meshVisibility[drawIndex] = bVisible ? 1 : 0;
	}
}
